# Lockfile Generation

## Overview

Lockfiles are generated by orchestrator (RYE) by resolving complete execution chain from a root tool down to primitives.

## Lockfile Generation Process

### Step 1: Start with Root Tool

```python
# User requests: generate lockfile for "my_tool@1.0.0"
tool_id = "my_tool"
version = "1.0.0"

# Load tool metadata
tool_metadata = load_tool_metadata(tool_id, version)
# Returns: __executor_id__, CONFIG_SCHEMA, file list, etc.
```

### Step 2: Recursively Resolve Chain

```python
def resolve_chain(tool_id: str, version: str) -> list:
    """Resolve complete executor chain."""
    chain = []

    current_tool_id = tool_id
    current_version = version

    while True:
        # Load current tool
        tool = load_tool_metadata(current_tool_id, current_version)
        chain.append(tool)

        executor_id = tool.get("__executor_id__")

        if executor_id is None:
            # Reached primitive
            break

        # Resolve to executor
        current_tool_id = executor_id

        # Get executor version from tool's dependencies
        # (if tool declares: dependencies=["subprocess>=1.0.0"])
        current_version = resolve_version(executor_id, tool.get("dependencies"))

    return chain

# Example result:
# [
#   {"item_id": "my_tool", "version": "1.0.0", "type": "tool", ...},
#   {"item_id": "python_runtime", "version": "2.0.0", "type": "runtime", ...},
#   {"item_id": "subprocess", "version": "1.0.1", "type": "primitive", ...}
# ]
```

### Step 3: Compute Integrity for Each Tool

```python
from lilux.primitives import compute_tool_integrity, compute_directive_integrity, compute_knowledge_integrity

lockfile_entries = []

for tool in chain:
    if tool["__tool_type__"] == "tool":
        # Python tool: compute hash of source code
        content = load_tool_file(tool["item_id"])
        integrity = compute_tool_integrity(
            tool_id=tool["item_id"],
            version=tool["version"],
            manifest=tool["CONFIG_SCHEMA"],
            files=tool["files"]
        )

    elif tool["__tool_type__"] == "directive":
        # Directive: compute hash of XML content
        xml_content = load_directive(tool["item_id"])
        integrity = compute_directive_integrity(
            directive_name=tool["item_id"],
            version=tool["version"],
            xml_content=xml_content,
            metadata=tool["metadata"]
        )

    elif tool["__tool_type__"] == "knowledge":
        # Knowledge: compute hash of markdown content
        md_content = load_knowledge(tool["item_id"])
        integrity = compute_knowledge_integrity(
            id=tool["item_id"],
            version=tool["version"],
            content=md_content,
            metadata=tool["metadata"]
        )

    lockfile_entries.append({
        "item_id": tool["item_id"],
        "version": tool["version"],
        "integrity": integrity,
        "type": tool["__tool_type__"]
    })
```

### Step 4: Build Lockfile Structure

```python
from lilux.primitives.lockfile import Lockfile, LockfileRoot

lockfile = Lockfile(
    lockfile_version=1,
    generated_at=datetime.now(timezone.utc).isoformat(),

    # Root is the first tool (user's tool)
    root=LockfileRoot(
        tool_id=chain[0]["item_id"],
        version=chain[0]["version"],
        integrity=chain[0]["integrity"]
    ),

    # Resolved chain is the full chain including root
    resolved_chain=[
        {
            "item_id": entry["item_id"],
            "version": entry["version"],
            "integrity": entry["integrity"],
            "executor": entry.get("__executor_id__") or entry["__tool_type__"],
            "files": entry.get("files", [])
        }
        for entry in chain
    ],

    # Optional: registry provenance
    registry={
        "url": "https://registry.example.com",
        "fetched_at": datetime.now(timezone.utc).isoformat()
    } if use_registry else None
)
```

### Step 5: Save Lockfile

```python
from lilux.primitives.lockfile import LockfileManager
from rye.config.lockfile_config import LockfileConfig

# Determine where to save (orchestrator responsibility)
config = LockfileConfig()
resolver = LockfileResolver(
    system_dir=config.get_system_lockfile_dir(),
    user_dir=config.get_user_lockfile_dir(),
    project_dir=config.get_project_lockfile_dir(Path.cwd()),
    scope=config.get_lockfile_scope()
)

# Write path (orchestrator resolves precedence)
write_path = resolver._resolve_write_path(
    lockfile.root.tool_id,
    lockfile.root.version
)
# Result: ~/.ai/lockfiles/my_tool@1.0.0.lock.json

# Save (Lilux responsibility - I/O only)
manager = LockfileManager()
saved_path = manager.save(lockfile, write_path)
```

## Complete Example

```python
# User: rye lockfile my_tool 1.0.0

# Orchestrator:
1. Load .ai/tools/my_tool.py
   - __executor_id__ = "python_runtime"
   - version = "1.0.0"
   - files = [{"path": "main.py", "sha256": "abc123..."}]

2. Resolve chain:
   - my_tool (1.0.0) → python_runtime (2.0.0) → subprocess (1.0.1)

3. Compute integrity for each:
   - my_tool: compute_tool_integrity(..., files=[...]) → "def456..."
   - python_runtime: compute_tool_integrity(..., files=[...]) → "ghi789..."
   - subprocess: compute_tool_integrity(...) → "jkl012..."

4. Build lockfile:
   {
     "lockfile_version": 1,
     "generated_at": "2026-01-30T12:00:00Z",
     "root": {
       "tool_id": "my_tool",
       "version": "1.0.0",
       "integrity": "def456..."
     },
     "resolved_chain": [
       {
         "item_id": "my_tool",
         "version": "1.0.0",
         "integrity": "def456...",
         "executor": "python_runtime",
         "files": [{"path": "main.py", "sha256": "abc123..."}]
       },
       {
         "item_id": "python_runtime",
         "version": "2.0.0",
         "integrity": "ghi789...",
         "executor": "subprocess"
       },
       {
         "item_id": "subprocess",
         "version": "1.0.1",
         "integrity": "jkl012...",
         "executor": null
       }
     ]
   }

5. Save:
   - ~/.ai/lockfiles/my_tool@1.0.0.lock.json
```

## Verification Workflow

When lockfile exists, orchestrator verifies before execution:

```python
# 1. Load lockfile
lockfile = lockfile_manager.load(lockfile_path)

# 2. Load current tools
current_chain = resolve_chain(lockfile.root.tool_id, lockfile.root.version)

# 3. Verify integrity
for entry in lockfile.resolved_chain:
    # Recompute integrity hash
    current_integrity = compute_integrity(entry["item_id"], ...)

    # Compare to stored
    if current_integrity != entry["integrity"]:
        raise ValueError(
            f"Tool {entry['item_id']} has been modified! "
            f"Expected: {entry['integrity']}, Got: {current_integrity}"
        )

# 4. Safe to execute
execute_chain(lockfile.resolved_chain)
```

## Related Documentation

- **Lockfile I/O:** `[[lilux/primitives/lockfile]]`
- **Integrity Helpers:** `[[lilux/primitives/integrity]]`
- **Lockfile Configuration:** `[[rye/config/lockfiles]]`
- **Chain Validation:** `[[rye/executor/chain-validator]]`
