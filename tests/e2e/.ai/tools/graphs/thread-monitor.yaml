# rye:signed:2026-02-23T04:43:36Z:99635e73d1d244d23e3147b67f018ed97c6a8aaf0f3097bccc3ad4671632b9ec:PvFQwZgjyqFf-ueauqymtL-RV2KxqrGZaMBiWynZTzcIo8msNJDe5GPW5K89rBxgYdA-n3ahPHGJevRavhXCAA==:9fbfabe975fa5a7f
version: "1.0.0"
tool_type: graph
executor_id: rye/core/runtimes/state-graph/runtime
category: graphs
description: "Spawn an LLM thread and monitor its progress via the thread registry"

config_schema:
  type: object
  properties:
    output_dir:
      type: string
      default: "graph-output/monitor"
  required: []

config:
  start: setup
  max_steps: 20
  on_error: continue

  nodes:
    setup:
      action:
        primary: execute
        item_type: tool
        item_id: rye/bash/bash
        params:
          command: "mkdir -p ${inputs.output_dir} && echo 'monitor setup complete'"
      next: spawn_task

    spawn_task:
      action:
        primary: execute
        item_type: tool
        item_id: rye/agent/threads/thread_directive
        params:
          directive_name: test/graphs/analyze_code
          async: true
          inputs:
            code_snippet: |
              import asyncio
              import json
              from pathlib import Path

              async def process_data(items):
                  results = []
                  for item in items:
                      result = await transform(item)
                      results.append(result)
                  return results

              async def transform(item):
                  await asyncio.sleep(0.1)
                  return {"original": item, "processed": True}

              async def main():
                  data = list(range(10))
                  output = await process_data(data)
                  Path("output.json").write_text(json.dumps(output, indent=2))

              if __name__ == "__main__":
                  asyncio.run(main())
            output_path: "${inputs.output_dir}/async_analysis.json"
          limit_overrides:
            turns: 6
            spend: 0.05
      assign:
        spawned_thread_id: "${result.thread_id}"
      next: log_spawn

    log_spawn:
      action:
        primary: execute
        item_type: tool
        item_id: rye/bash/bash
        params:
          command: "echo '[spawn] Thread ${state.spawned_thread_id} launched at $(date -Iseconds)' > ${inputs.output_dir}/monitor.log"
      next: check_status

    check_status:
      action:
        primary: execute
        item_type: tool
        item_id: rye/bash/bash
        params:
          command: "sleep 2 && echo 'status_check_done'"
      next: read_thread_result

    read_thread_result:
      action:
        primary: execute
        item_type: tool
        item_id: rye/bash/bash
        params:
          command: "echo '[check] Checking thread result at $(date -Iseconds)' >> ${inputs.output_dir}/monitor.log && cat ${inputs.output_dir}/async_analysis.json 2>/dev/null && echo '[done] Analysis file found' >> ${inputs.output_dir}/monitor.log || echo '[wait] Analysis not ready yet' >> ${inputs.output_dir}/monitor.log"
      assign:
        thread_output: "${result.stdout}"
      next: write_final_report

    write_final_report:
      action:
        primary: execute
        item_type: tool
        item_id: rye/bash/bash
        params:
          command: "echo '' >> ${inputs.output_dir}/monitor.log && echo '[report] Final status at $(date -Iseconds)' >> ${inputs.output_dir}/monitor.log && echo '# Thread Monitor Report' > ${inputs.output_dir}/report.md && echo '' >> ${inputs.output_dir}/report.md && echo '## Spawned Thread' >> ${inputs.output_dir}/report.md && echo 'Thread ID: ${state.spawned_thread_id}' >> ${inputs.output_dir}/report.md && echo '' >> ${inputs.output_dir}/report.md && echo '## Monitor Log' >> ${inputs.output_dir}/report.md && cat ${inputs.output_dir}/monitor.log >> ${inputs.output_dir}/report.md && echo '' >> ${inputs.output_dir}/report.md && echo '## Thread Output' >> ${inputs.output_dir}/report.md && echo '${state.thread_output}' >> ${inputs.output_dir}/report.md && cat ${inputs.output_dir}/report.md"
      assign:
        final_report: "${result.stdout}"
      next: done

    done:
      type: return
