<!-- rye:signed:2026-02-18T10:01:01Z:72378b8319c94dbcf647bd767ac7b7df9b19f67ef712b49ee5790d2f9a5c82a8:v7kPU10OR6SfRbYOVK_sUEWNHKeT5zqXAD4yK_lPWbor5Uwv1ahI1XiyVePr-qWjMnxsH0AXQxPLDMmYZhzyCw==:440443d0858f0199 -->
```yaml
name: graphs/graphs/graphs-1771408836
title: "State: graphs (graphs-1771408836)"
entry_type: graph_state
category: graphs/graphs
version: "1.0.0"
graph_id: graphs
graph_run_id: graphs-1771408836
parent_thread_id: 
status: completed
current_node: done
step_count: 13
updated_at: 2026-02-18T10:01:01Z
tags: [graph_state]
```

{
  "inputs": {
    "output_dir": "graph-output/full-review",
    "capabilities": [
      "rye.execute.tool.*",
      "rye.execute.directive.*",
      "rye.search.*",
      "rye.load.*",
      "rye.sign.*"
    ],
    "depth": 5
  },
  "files": [
    {
      "path": "graph-output/full-review/samples/utils.py",
      "analysis_path": "graph-output/full-review/analyses/utils_analysis.json"
    },
    {
      "path": "graph-output/full-review/samples/cache.py",
      "analysis_path": "graph-output/full-review/analyses/cache_analysis.json"
    }
  ],
  "file_contents": [
    {
      "success": true,
      "output": "import hashlib\nimport hmac\nimport os\nfrom typing import Optional\n\ndef generate_token(length: int = 32) -> str:\n    return os.urandom(length).hex()\n\ndef hash_password(password: str, salt: Optional[str] = None) -> tuple:\n    if salt is None:\n        salt = os.urandom(16).hex()\n    hashed = hashlib.pbkdf2_hmac('sha256', password.encode(), salt.encode(), 100000)\n    return hashed.hex(), salt\n\ndef verify_password(password: str, hashed: str, salt: str) -> bool:\n    new_hash, _ = hash_password(password, salt)\n    return hmac.compare_digest(new_hash, hashed)\n\ndef sanitize_input(text: str) -> str:\n    dangerous = ['<script>', '</script>', 'javascript:', 'onerror=']\n    result = text\n    for pattern in dangerous:\n        result = result.replace(pattern, '')\n    return result.strip()\n",
      "stdout": "import hashlib\nimport hmac\nimport os\nfrom typing import Optional\n\ndef generate_token(length: int = 32) -> str:\n    return os.urandom(length).hex()\n\ndef hash_password(password: str, salt: Optional[str] = None) -> tuple:\n    if salt is None:\n        salt = os.urandom(16).hex()\n    hashed = hashlib.pbkdf2_hmac('sha256', password.encode(), salt.encode(), 100000)\n    return hashed.hex(), salt\n\ndef verify_password(password: str, hashed: str, salt: str) -> bool:\n    new_hash, _ = hash_password(password, salt)\n    return hmac.compare_digest(new_hash, hashed)\n\ndef sanitize_input(text: str) -> str:\n    dangerous = ['<script>', '</script>', 'javascript:', 'onerror=']\n    result = text\n    for pattern in dangerous:\n        result = result.replace(pattern, '')\n    return result.strip()\n",
      "stderr": "",
      "exit_code": 0,
      "truncated": false
    },
    {
      "success": true,
      "output": "import time\nfrom collections import OrderedDict\nfrom threading import Lock\n\nclass LRUCache:\n    def __init__(self, capacity: int = 128, ttl: int = 300):\n        self.capacity = capacity\n        self.ttl = ttl\n        self.cache = OrderedDict()\n        self.timestamps = {}\n        self.lock = Lock()\n\n    def get(self, key: str):\n        with self.lock:\n            if key not in self.cache:\n                return None\n            if time.time() - self.timestamps[key] > self.ttl:\n                del self.cache[key]\n                del self.timestamps[key]\n                return None\n            self.cache.move_to_end(key)\n            return self.cache[key]\n\n    def put(self, key: str, value) -> None:\n        with self.lock:\n            if key in self.cache:\n                self.cache.move_to_end(key)\n            self.cache[key] = value\n            self.timestamps[key] = time.time()\n            if len(self.cache) > self.capacity:\n                oldest = next(iter(self.cache))\n                del self.cache[oldest]\n                del self.timestamps[oldest]\n\n    def invalidate(self, key: str) -> bool:\n        with self.lock:\n            if key in self.cache:\n                del self.cache[key]\n                del self.timestamps[key]\n                return True\n            return False\n\n    def clear(self) -> int:\n        with self.lock:\n            count = len(self.cache)\n            self.cache.clear()\n            self.timestamps.clear()\n            return count\n",
      "stdout": "import time\nfrom collections import OrderedDict\nfrom threading import Lock\n\nclass LRUCache:\n    def __init__(self, capacity: int = 128, ttl: int = 300):\n        self.capacity = capacity\n        self.ttl = ttl\n        self.cache = OrderedDict()\n        self.timestamps = {}\n        self.lock = Lock()\n\n    def get(self, key: str):\n        with self.lock:\n            if key not in self.cache:\n                return None\n            if time.time() - self.timestamps[key] > self.ttl:\n                del self.cache[key]\n                del self.timestamps[key]\n                return None\n            self.cache.move_to_end(key)\n            return self.cache[key]\n\n    def put(self, key: str, value) -> None:\n        with self.lock:\n            if key in self.cache:\n                self.cache.move_to_end(key)\n            self.cache[key] = value\n            self.timestamps[key] = time.time()\n            if len(self.cache) > self.capacity:\n                oldest = next(iter(self.cache))\n                del self.cache[oldest]\n                del self.timestamps[oldest]\n\n    def invalidate(self, key: str) -> bool:\n        with self.lock:\n            if key in self.cache:\n                del self.cache[key]\n                del self.timestamps[key]\n                return True\n            return False\n\n    def clear(self) -> int:\n        with self.lock:\n            count = len(self.cache)\n            self.cache.clear()\n            self.timestamps.clear()\n            return count\n",
      "stderr": "",
      "exit_code": 0,
      "truncated": false
    }
  ],
  "analysis_thread_1": "test/graphs/analyze_code-1771408837",
  "analysis_thread_2": "test/graphs/analyze_code-1771408846",
  "total_functions": "\n",
  "summary_input": "{\"analyses\": [\n,\n]}\n",
  "summary_thread": "test/graphs/summarize_text-1771408856",
  "_last_error": {
    "node": "run_nested_graph",
    "error": "Permission denied: no capabilities. Cannot execute tool 'rye/bash/bash'"
  },
  "nested_result": "failed",
  "final_report": "report complete\n# Full Review Pipeline Report\n\n## Pipeline Summary\n- Analysis threads: 2 files analyzed\n- Total functions found: \n\n- Nested graph result: failed\n\n## Analysis Results\n### utils.py\n\n### cache.py\n\n## Review / Summary\nThe provided text contains a JSON structure with an empty analyses array. This minimal JSON object has no actual data or analysis content to summarize. The original content is essentially a template or placeholder structure.\n## Nested Pipeline Output\n"
}