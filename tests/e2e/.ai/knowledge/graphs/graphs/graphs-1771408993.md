<!-- rye:signed:2026-02-18T10:03:18Z:4e9ad01dfbc9bb2a625dccd1783ef00520a66b9e4da33c9699e0b8d414ca70f7:z6uX13T0f9v6fBeFtb_ZX8hwpKMGGaACqCEWgTvuyBQKaUORBgi5Y2FOIQfMU2wyrUh5vuBTqNygeubeFD62Ag==:440443d0858f0199 -->
```yaml
name: graphs/graphs/graphs-1771408993
title: "State: graphs (graphs-1771408993)"
entry_type: graph_state
category: graphs/graphs
version: "1.0.0"
graph_id: graphs
graph_run_id: graphs-1771408993
parent_thread_id: 
status: completed
current_node: done
step_count: 5
updated_at: 2026-02-18T10:03:18Z
tags: [graph_state]
```

{
  "inputs": {
    "file_path": "graph-output/full-review/samples/cache.py",
    "output_dir": "graph-output/full-review/nested-pipeline",
    "capabilities": [
      "rye.execute.tool.*",
      "rye.execute.directive.*",
      "rye.search.*",
      "rye.load.*",
      "rye.sign.*"
    ],
    "depth": 5
  },
  "source_code": "import time\nfrom collections import OrderedDict\nfrom threading import Lock\n\nclass LRUCache:\n    def __init__(self, capacity: int = 128, ttl: int = 300):\n        self.capacity = capacity\n        self.ttl = ttl\n        self.cache = OrderedDict()\n        self.timestamps = {}\n        self.lock = Lock()\n\n    def get(self, key: str):\n        with self.lock:\n            if key not in self.cache:\n                return None\n            if time.time() - self.timestamps[key] > self.ttl:\n                del self.cache[key]\n                del self.timestamps[key]\n                return None\n            self.cache.move_to_end(key)\n            return self.cache[key]\n\n    def put(self, key: str, value) -> None:\n        with self.lock:\n            if key in self.cache:\n                self.cache.move_to_end(key)\n            self.cache[key] = value\n            self.timestamps[key] = time.time()\n            if len(self.cache) > self.capacity:\n                oldest = next(iter(self.cache))\n                del self.cache[oldest]\n                del self.timestamps[oldest]\n\n    def invalidate(self, key: str) -> bool:\n        with self.lock:\n            if key in self.cache:\n                del self.cache[key]\n                del self.timestamps[key]\n                return True\n            return False\n\n    def clear(self) -> int:\n        with self.lock:\n            count = len(self.cache)\n            self.cache.clear()\n            self.timestamps.clear()\n            return count\n",
  "analysis_result": "I'll analyze the provided code snippet and execute the directive steps.\n\nLet me first analyze the code:\n\n**Language:** Python\n\n**Function/Method Definitions:**\n1. `__init__` (constructor)\n2. `get`\n3. `put`\n4. `invalidate`\n5. `clear`\n\n**Total: 5 methods**\n\n**Summary:** This code implements an LRU (Least Recently Used) Cache class with TTL (Time To Live) support, using OrderedDict for efficient tracking of access order and timestamps for expiration. The cache maintains a fixed capacity and automatically evicts the oldest item when full, while also removing expired entries based on a configurable TTL. Thread-safety is ensured through a Lock mechanism.\n\nNow I'll execute the directive steps:",
  "thread_id": "test/graphs/analyze_code-1771408993",
  "analysis_json": "{\"language\": \"Python\", \"function_count\": 5, \"summary\": \"This code implements an LRU (Least Recently Used) Cache class with TTL (Time To Live) support, using OrderedDict for efficient tracking of access order and timestamps for expiration. The cache maintains a fixed capacity and automatically evicts the oldest item when full, while also removing expired entries based on a configurable TTL. Thread-safety is ensured through a Lock mechanism.\"}",
  "report_written": true
}