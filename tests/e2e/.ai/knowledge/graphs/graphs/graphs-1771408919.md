<!-- rye:signed:2026-02-18T10:03:18Z:839e5fd1e487ab642a45a8b192a6803b20101347c0a58c70ce69e81b916c5335:gmrtZmK6CnqAwunNTepFvLpr4dWDJriar19va3ewjl0LPL0iCxyOwlMdd0ChdZYMDeZf6smi2nF3NpCtVYvnCg==:440443d0858f0199 -->
```yaml
id: graphs/graphs/graphs-1771408919
title: "State: graphs (graphs-1771408919)"
entry_type: graph_state
category: graphs/graphs
version: "1.0.0"
graph_id: graphs
graph_run_id: graphs-1771408919
parent_thread_id: 
status: completed
current_node: done
step_count: 12
updated_at: 2026-02-18T10:03:18Z
tags: [graph_state]
```

{
  "inputs": {
    "output_dir": "graph-output/full-review",
    "capabilities": [
      "rye.execute.tool.*",
      "rye.execute.directive.*",
      "rye.search.*",
      "rye.load.*",
      "rye.sign.*"
    ],
    "depth": 5
  },
  "files": [
    {
      "path": "graph-output/full-review/samples/utils.py",
      "analysis_path": "graph-output/full-review/analyses/utils_analysis.json"
    },
    {
      "path": "graph-output/full-review/samples/cache.py",
      "analysis_path": "graph-output/full-review/analyses/cache_analysis.json"
    }
  ],
  "file_contents": [
    {
      "success": true,
      "output": "import hashlib\nimport hmac\nimport os\nfrom typing import Optional\n\ndef generate_token(length: int = 32) -> str:\n    return os.urandom(length).hex()\n\ndef hash_password(password: str, salt: Optional[str] = None) -> tuple:\n    if salt is None:\n        salt = os.urandom(16).hex()\n    hashed = hashlib.pbkdf2_hmac('sha256', password.encode(), salt.encode(), 100000)\n    return hashed.hex(), salt\n\ndef verify_password(password: str, hashed: str, salt: str) -> bool:\n    new_hash, _ = hash_password(password, salt)\n    return hmac.compare_digest(new_hash, hashed)\n\ndef sanitize_input(text: str) -> str:\n    dangerous = ['<script>', '</script>', 'javascript:', 'onerror=']\n    result = text\n    for pattern in dangerous:\n        result = result.replace(pattern, '')\n    return result.strip()\n",
      "stdout": "import hashlib\nimport hmac\nimport os\nfrom typing import Optional\n\ndef generate_token(length: int = 32) -> str:\n    return os.urandom(length).hex()\n\ndef hash_password(password: str, salt: Optional[str] = None) -> tuple:\n    if salt is None:\n        salt = os.urandom(16).hex()\n    hashed = hashlib.pbkdf2_hmac('sha256', password.encode(), salt.encode(), 100000)\n    return hashed.hex(), salt\n\ndef verify_password(password: str, hashed: str, salt: str) -> bool:\n    new_hash, _ = hash_password(password, salt)\n    return hmac.compare_digest(new_hash, hashed)\n\ndef sanitize_input(text: str) -> str:\n    dangerous = ['<script>', '</script>', 'javascript:', 'onerror=']\n    result = text\n    for pattern in dangerous:\n        result = result.replace(pattern, '')\n    return result.strip()\n",
      "stderr": "",
      "exit_code": 0,
      "truncated": false
    },
    {
      "success": true,
      "output": "import time\nfrom collections import OrderedDict\nfrom threading import Lock\n\nclass LRUCache:\n    def __init__(self, capacity: int = 128, ttl: int = 300):\n        self.capacity = capacity\n        self.ttl = ttl\n        self.cache = OrderedDict()\n        self.timestamps = {}\n        self.lock = Lock()\n\n    def get(self, key: str):\n        with self.lock:\n            if key not in self.cache:\n                return None\n            if time.time() - self.timestamps[key] > self.ttl:\n                del self.cache[key]\n                del self.timestamps[key]\n                return None\n            self.cache.move_to_end(key)\n            return self.cache[key]\n\n    def put(self, key: str, value) -> None:\n        with self.lock:\n            if key in self.cache:\n                self.cache.move_to_end(key)\n            self.cache[key] = value\n            self.timestamps[key] = time.time()\n            if len(self.cache) > self.capacity:\n                oldest = next(iter(self.cache))\n                del self.cache[oldest]\n                del self.timestamps[oldest]\n\n    def invalidate(self, key: str) -> bool:\n        with self.lock:\n            if key in self.cache:\n                del self.cache[key]\n                del self.timestamps[key]\n                return True\n            return False\n\n    def clear(self) -> int:\n        with self.lock:\n            count = len(self.cache)\n            self.cache.clear()\n            self.timestamps.clear()\n            return count\n",
      "stdout": "import time\nfrom collections import OrderedDict\nfrom threading import Lock\n\nclass LRUCache:\n    def __init__(self, capacity: int = 128, ttl: int = 300):\n        self.capacity = capacity\n        self.ttl = ttl\n        self.cache = OrderedDict()\n        self.timestamps = {}\n        self.lock = Lock()\n\n    def get(self, key: str):\n        with self.lock:\n            if key not in self.cache:\n                return None\n            if time.time() - self.timestamps[key] > self.ttl:\n                del self.cache[key]\n                del self.timestamps[key]\n                return None\n            self.cache.move_to_end(key)\n            return self.cache[key]\n\n    def put(self, key: str, value) -> None:\n        with self.lock:\n            if key in self.cache:\n                self.cache.move_to_end(key)\n            self.cache[key] = value\n            self.timestamps[key] = time.time()\n            if len(self.cache) > self.capacity:\n                oldest = next(iter(self.cache))\n                del self.cache[oldest]\n                del self.timestamps[oldest]\n\n    def invalidate(self, key: str) -> bool:\n        with self.lock:\n            if key in self.cache:\n                del self.cache[key]\n                del self.timestamps[key]\n                return True\n            return False\n\n    def clear(self) -> int:\n        with self.lock:\n            count = len(self.cache)\n            self.cache.clear()\n            self.timestamps.clear()\n            return count\n",
      "stderr": "",
      "exit_code": 0,
      "truncated": false
    }
  ],
  "analysis_thread_1": "test/graphs/analyze_code-1771408920",
  "analysis_thread_2": "test/graphs/analyze_code-1771408925",
  "total_functions": "9\n",
  "review_code": "import hashlib\nimport hmac\nimport os\nfrom typing import Optional\n\ndef generate_token(length: int = 32) -> str:\n    return os.urandom(length).hex()\n\ndef hash_password(password: str, salt: Optional[str] = None) -> tuple:\n    if salt is None:\n        salt = os.urandom(16).hex()\n    hashed = hashlib.pbkdf2_hmac('sha256', password.encode(), salt.encode(), 100000)\n    return hashed.hex(), salt\n\ndef verify_password(password: str, hashed: str, salt: str) -> bool:\n    new_hash, _ = hash_password(password, salt)\n    return hmac.compare_digest(new_hash, hashed)\n\ndef sanitize_input(text: str) -> str:\n    dangerous = ['<script>', '</script>', 'javascript:', 'onerror=']\n    result = text\n    for pattern in dangerous:\n        result = result.replace(pattern, '')\n    return result.strip()\n",
  "_last_error": {
    "node": "run_orchestrate",
    "error": "Escalation requested"
  },
  "nested_result": true,
  "final_report": "report complete\n# Full Review Pipeline Report\n\n## Pipeline Summary\n- Analysis threads: 2 files analyzed\n- Total functions found: 9\n\n- Nested graph result: True\n\n## Analysis Results\n### utils.py\n{\"language\": \"Python\", \"function_count\": 4, \"summary\": \"This code provides security-related utilities for a Python application, including functions for generating secure tokens, hashing and verifying passwords using PBKDF2 with salt, and sanitizing user input by removing potentially dangerous HTML/JavaScript patterns. The implementation follows cryptographic best practices such as salt generation and constant-time comparison for password verification.\"}\n### cache.py\n{\"language\": \"Python\", \"function_count\": 5, \"summary\": \"This code implements an LRU (Least Recently Used) Cache with TTL (Time To Live) functionality. The cache stores key-value pairs with a maximum capacity, automatically evicting the least recently used items when full and removing entries that have exceeded their time-to-live. It uses thread-safe locks to ensure safe concurrent access.\"}\n## Review / Summary\n\n## Nested Pipeline Output\n# Code Analysis Report\n\n## Source File\ngraph-output/full-review/samples/cache.py\n\n## Analysis\n{\"language\": \"Python\", \"function_count\": 5, \"summary\": \"This code implements an LRU (Least Recently Used) Cache class with TTL (Time To Live) support, using OrderedDict for efficient tracking of access order and timestamps for expiration. The cache maintains a fixed capacity and automatically evicts the oldest item when full, while also removing expired entries based on a configurable TTL. Thread-safety is ensured through a Lock mechanism.\"}\n\n## Thread\ntest/graphs/analyze_code-1771408993\n"
}